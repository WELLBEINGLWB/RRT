#ifndef _MOTION_PLAN_H_
#define _MOTION_PLAN_H_
#include "RRTStruct.h"

#define Threshold 0.85

namespace MotionPlan
{
  class RRT
  {
  public:
    /// Checks whether a point (xTest,yTest) is in collision
    /// with any of the obstacles defined by their min/max coordinates.
    bool clear(double xTest, double yTest);

    /// A geometrically exact query for whether the line between
    /// points (xStart,yStart) and (xDest,yDest) collides with any
    /// of the obstacles defined by their mein/max coordinates
    bool link(double xStart, double yStart,
              double xDest, double yDest,
              double stepSize);

    double f_xy(double x,double y);

    /// Represents a node in an RRT
    /// Stores its own positional information, as well as
    /// a list of its children and a pointer to its parent
    class TreeNode
    {
    public:
      double x, y;
      std::vector<TreeNode*> children;
      TreeNode* parent;

      /// Used for outputting the tree
      int nodeID;

      /// Given a point (sampleX, sampleY), find the nearest node within
      /// this node's subtree (including itself), and place the distance between
      /// that node and the point in distance
      TreeNode* nearestNode(double sampleX, double sampleY, double* distance);

      /// Delete this node's subtree from memory (excluding itself, of course)
      void deleteChildren();
    };

    /// Basic structure used to encapsulate two nodes into an edge.
    /// Used only for outputting the tree
    class Edge
    {
    public:
      int node1; int node2;

      Edge(int n1, int n2) : node1(n1), node2(n2) {}
    };

    /// Initializes the RRT with the values given, as well as seeds the
    /// random number generator with the system time.
    RRT(double* xMin, double* xMax, double* yMin, double* yMax, int numObs,
        double xL, double xR, double yT, double yB,
        double xS, double yS,
        double xG, double yG,
        double step);

    /// Initializes the RRT as above, except uses data from a file to do so.
    RRT(std::string fileName);

    /// ポテンシャル場の定義
    void CreatePotentialField();

    /// ポテンシャルの評価用関数
    void Evaluation(int num);
    char savefilename[64] = {'\0'};

    /// Destructor
    ~RRT();

    /// Initializes (or re-initializes) the RRT using a data file
    void initFromFile(std::string fileName);

    /// Main pathfinding function of the RRT.
    /// If, a path is found between start and goal within MAX_ITERATIONS,
    /// the sequence of node IDs is placed in nodePath, the number of iterations performed
    /// is placed in iterations, and the length of the path is in pathLength.
    ///
    /// As well, the attributes 'nodes' and 'edges' are populated with the tree
    /// generated by this function, for output purposes.
    bool findPath(int* iterations, int* nodePath, int* pathLength);
    void RRTloop(int* iterations, int* nodePath, int* pathLength, std::ostream& nodeData);
    int GetRandom(double min, double max);
    double Distance();
    void smoothing(int loop);

    /// Generates a point (x,y) within the confines of the space and places
    /// its coordinates in 'x' and 'y'.
    void randFreeSample(double* x, double* y);

    /// Given a point (x,y), returns a pointer to the TreeNode in the RRT
    /// closest to that point.
    TreeNode* nearestNode(double x, double y);

    /// Given a pointer to the nearest TreeNode in the RRT to a point (x,y),
    /// will attempt to create a new TreeNode of distance = stepSize from
    /// nearest in the direction of (x,y). If this node can't be created
    /// (i.e. there's an obstacle between nearest and this new node), this
    /// function returns NULL. If the new node is valid, a pointer to it is
    /// returned.
    TreeNode* genNewNode(const TreeNode* nearest, double x, double y);

    bool transitionTest(const TreeNode* child, const TreeNode* parent);
    bool minExpansionControl(double randMotionDistance);

    /// Checks whether the goal position is within stepSize distance and
    /// reachable from checkNode. If so, return true. If it's too far away
    /// or if link() between checkNode and the goal fails, return false.
    bool checkGoal(const TreeNode* checkNode);
    bool PathCheck(int* pathLength);

    void CreateCube(std::ostream &cube);
    /// Write out information about the tree into outStream.
    /// Displays the RRT's nodes and edges.
    void outputTree(std::ostream& outStream);
    void output_plt(string plt_output);
    void OutputFinalPath(std::vector<POINT> *finalpath);

    /// Pointer to the root (start) node of the RRT.
    TreeNode* root;

    /// Min/Max coordinates of all obstacles in space.
    double* xMin;
    double* xMax;
    double* yMin;
    double* yMax;

    /// Number of obstacles in space.
    int numObstacles;

    /// Start position in space
    double xStart;
    double yStart;

    /// Goal position in space
    double xGoal;
    double yGoal;

    /// Max. distance toward each sampled position we
    /// should grow our tree
    double stepSize;

    /// Boundaries of the space
    double xLeft;
    double xRight;
    double yTop;
    double yBottom;

    /// List of nodes in RRT (for output)
    std::vector<TreeNode*> nodes;

    /// List of edges in RRT (for output)
    std::vector<Edge> edges;

    /// RRTの最終的な経路の座標データ
    std::vector<POINT> paths;

    /// ポテンシャル場を形成するための障害物点を定義するようベクター
    std::vector<POINT> vobstacle;

    /// Transtion Test
    double Temperature = 100;
    double KConstant;
    unsigned int maxStatesFailed = 3.0;
    double tempChangeFactor = 2.0;
    double minTemperature = 0.1;
    double initTemperature = 10e-6;
    unsigned int numStatesFailed;

     /// Minimum Expansion Control
    double nonfrontierCount = 1;
    double frontierCount = 1;
    double frontierThreshold = 0.0;
    double frontierNodeRatio = 0.1;

    /// Maximum number of iterations to run when finding a path
    /// before givin up.
    static const int MAX_ITERATIONS = 100000;
  };
};

#endif
