#include "MotionPlan.h"
#include <cmath>
#include <iterator>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <fstream>
#include <unistd.h>

// Simple iterates over each object in the space
// and checks whether the test point lies inside the obstacle.
// (xTest, yTest)が障害物の中にあるかどうかの判定
bool clear(const double* xMin, const double* xMax,
           const double* yMin, const double* yMax,
           const double* zMin, const double* zMax,
           int numObstacles,
           double xTest, double yTest, double zTest)
{
  for (int i = 0; i < numObstacles; ++i) { // 障害物の範囲内ならreturn 1
    if (xTest >= xMin[i] && xTest <= xMax[i] &&
        yTest >= yMin[i] && yTest <= yMax[i] &&
        zTest >= zMin[i] && zTest <= zMax[i]) {
      return false;
    }
  }

  return true; // すべての障害物の中に入ってなかったらreturn 0
}

// First finds line between (xStart, yStart) and (xDest, yDest), called
// 'link-line'.
// Then, for each obstacle, we perform 1 of 3 different checks depending
// on whether the line is of zero, infinite, or nonzero slope.
// 最初に(xStart,yStart)と(xDest,yDest)の間の線を見つける。'link-line'と呼ぶよ。
// それぞれの障害物において、'link-line'が0、無限か有限なのかどうかの依存をチェック。


// VERTICAL/HORIZONTAL
// If either of the endpoints of link-line is inside the obstacle, collision.
// For vertical: for link-line x = a, if x is between xMin and xMax of
// the obstacle, and the endpoints of the link-line lie on either side of
// the obstacle, collision.
// For horizontal: for link-line y = a, if y is between yMin and yMax of the
// obstacle, and the endpoints of the link-line lie on either side of the
// obstacle, collision.
// Otherwise, no collision.
// 水平/垂直
// link-lineの終端のどちらかが障害物か衝突の中にある場合、
// 水平の場合、link-lineはx = aで、もしxが障害物のxMinとxMaxの範囲内やまたがっていたら...
// 垂直の場合、link-lineはy = aで、.....垂直と一緒
// その他の場合なら障害物とあたってない！


// NONZERO SLOPE
// For each side of the obstacle, we use (y-y1)=m(x-x1) to find
// the point of intersection of link-line and the line that runs
// through the side of the obstacle (called side-line).
// If that intersection point lies on the side of the obstacle, we then
// check whether our start and dest points lie on either side of side-line.
// If so, we have a collision. In any case besides the one defined here,
// there is no collision.
// 障害物のそれぞれのサイドにおいて、(y-y1)=m(x-x1)で考える。

bool link(const double* xMin, const double* xMax,
          const double* yMin, const double* yMax,
          const double* zMin, const double* zMax,
          int numObstacles,
          double xStart, double yStart, double zStart,
          double xDest, double yDest, double zDest)
{
  if (!clear(xMin, xMax, yMin, yMax, zMin, zMax, numObstacles, xStart, yStart, zStart) ||
      !clear(xMin, xMax, yMin, yMax, zMin, zMax, numObstacles, xDest, yDest, zDest)) {
    return false;
  }

  return true;
}

bool MotionPlan::equal(double x, double y) { return (fabs(x - y) < EPSILON); }

// First recurses through child nodes to find nearest node to xSample and
// ySample
// within children's subtrees, then compares the nearest node from that
// to the calling node's position itself. Returns nearest node and distance
// from nearest node to sample point.
MotionPlan::RRT::TreeNode* MotionPlan::RRT::TreeNode::nearestNode(
    double xSample, double ySample, double zSample, double* nearestDist)

{
  (*nearestDist) = -1;
  double dist;
  double dx, dy, dz;
  TreeNode* nearest = NULL;
  TreeNode* childNearest = NULL;

  // Find nearest node of all this node's children's trees
  std::vector<TreeNode*>::iterator child;
  for (child = children.begin(); child != children.end(); ++child) {
    childNearest = (*child)->nearestNode(xSample, ySample, zSample, &dist);

    // Is this child's nearest node closer than the previous
    // nearest node?
    if (dist < (*nearestDist) || nearest == NULL){
      nearest = childNearest;
      (*nearestDist) = dist;
    }
  }

  // Compare now to this current node
  dx = x - xSample;
  dy = y - ySample;
  dz = z - zSample;
  dist = dx*dx + dy*dy + dz*dz;

  if (dist < (*nearestDist) || nearest == NULL){
    nearest = this;
    (*nearestDist) = dist;
  }

  return nearest;
}

void MotionPlan::RRT::TreeNode::deleteChildren()
{
  std::vector<TreeNode*>::iterator child;
  for (child = children.begin(); child != children.end(); ++child){
    if ((*child) != NULL){
      (*child)->deleteChildren();
      delete (*child);
    }
  }

  children.clear();
}


MotionPlan::RRT::RRT(double* xMini, double* xMaxi, double* yMini, double* yMaxi, double* zMini, double* zMaxi,int numObs,
 double xL, double xR, double yT, double yB, double zT, double zB,
 double xS, double yS, double zS,
 double xG, double yG, double zG,
 double step) :
xMin(xMini), xMax(xMaxi), yMin(yMini), yMax(yMaxi), zMin(zMini), zMax(zMaxi), numObstacles(numObs),
xLeft(xL), xRight(xR), yTop(yT), yBottom(yB), zTop(zT), zBottom(zB),
xStart(xS), yStart(yS), zStart(zS),
xGoal(xG), yGoal(yG), zGoal(zG),
stepSize(step),
root(NULL)
{
  srand((unsigned int)time(NULL));
}

MotionPlan::RRT::RRT(std::string fileName):
root(NULL), xMin(NULL), xMax(NULL), yMin(NULL), yMax(NULL), zMin(NULL), zMax(NULL)
{
  initFromFile(fileName);
  srand((unsigned int)time(NULL));
}

// Reads initialization info for this RRT from a file with the
// following format:
// xLeft
// xRight
// yBottom
// yTop
// numObstacles
// xMin1 xMax1 yMin1 yMax1
// ...
// xMinN xMaxN yMinN yMaxN
// xStart yStart
// xGoal yGoal
// Stepsize
void MotionPlan::RRT::initFromFile(std::string fileName){
  if (xMin != NULL)
    delete [] xMin;
  if (xMax != NULL)
    delete [] xMax;
  if (yMin != NULL)
    delete [] yMin;
  if (yMax != NULL)
    delete [] yMax;
  if (zMin != NULL)
    delete [] zMin;
  if (zMax != NULL)
    delete [] zMax;

  std::ifstream input(fileName.c_str());

  input >> xLeft >> xRight >> yBottom >> yTop >> zBottom >> zTop >> numObstacles;

  xMin = new double[numObstacles];
  xMax = new double[numObstacles];
  yMin = new double[numObstacles];
  yMax = new double[numObstacles];
  zMin = new double[numObstacles];
  zMax = new double[numObstacles];

  for (int i = 0; i < numObstacles; ++i){
    input >> xMin[i] >> xMax[i] >> yMin[i] >> yMax[i] >> zMin[i] >> zMax[i];
  }

  input >> xStart >> yStart >> zStart >> xGoal >> yGoal >> zGoal >> stepSize;

  input.close();
}

MotionPlan::RRT::~RRT(){
  if (root != NULL){
    root->deleteChildren();
    delete root;
    root = NULL;
  }

  if (xMin != NULL){
    delete [] xMin;
    xMin = NULL;
  }

  if (xMax != NULL){
    delete [] xMax;
    xMax = NULL;
  }

  if (yMin != NULL){
    delete [] yMin;
    yMin = NULL;
  }

  if (yMax != NULL){
    delete [] yMax;
    yMax = NULL;
  }

  if (zMin != NULL){
    delete [] zMin;
    zMin = NULL;
  }

  if (zMax != NULL){
    delete [] zMax;
    zMax = NULL;
  }
}

// For x and y, generates a random number, scales it to [0,1], then
// scales it to the distance between the boundaries, then offsets it
// by the left/bottom value. This effectively generates x and y values
// in [xLeft, xRight] and [yBottom,yTop], respectively. We continue
// generating points until we find one that is clear of all obstacles.
void MotionPlan::RRT::randFreeSample(double* x, double* y, double* z){
  // do{
  //   (*x) = (((double)rand())/RAND_MAX)*(xRight - xLeft) + xLeft;
  //   (*y) = (((double)rand())/RAND_MAX)*(yTop - yBottom) + yBottom;
  //   (*z) = (((double)rand())/RAND_MAX)*(zTop - zBottom) + zBottom;
  // } while(!clear(xMin, xMax, yMin, yMax, zMin, zMax, numObstacles, *x, *y, *z));
}

// Recurses through the RRT, calling nearestNode() on each node.
MotionPlan::RRT::TreeNode* MotionPlan::RRT::nearestNode(double x, double y, double z){
  TreeNode* nearest = NULL;
  double distance;
  nearest = root->nearestNode(x, y, z, &distance);

  return nearest;
}

// Finds the vector from the nearest node to the sample point (x,y),
// normalizes it, and then scales it by stepSize to get our new point to add
// to the tree, given that link() between the nearest node and the new node
// does not fail.
MotionPlan::RRT::TreeNode* MotionPlan::RRT::genNewNode(const TreeNode* nearest,
 double x, double y, double z){
  double dx = x - nearest->x;
  double dy = y - nearest->y;
  double dz = z - nearest->z;
  double dist = sqrt(dx*dx + dy*dy + dz*dz);

  double newX = nearest->x + stepSize*(dx / dist);
  double newY = nearest->y + stepSize*(dy / dist);
  double newZ = nearest->z + stepSize*(dz / dist);

  if (link(xMin, xMax,
           yMin, yMax,
           zMin, zMax,
           numObstacles,
           nearest->x, nearest->y, nearest->z,
           newX, newY, newZ)){

    TreeNode* newNode = new TreeNode;
    newNode->x = newX;
    newNode->y = newY;
    newNode->z = newZ;

    return newNode;
  }
  else{
    return NULL;
  }
}

// Checks if the square of the distance between this node and
// the goal position is within the square of the stepSize. If so,
// check link() between the two positions. Return true if link()
// passes; false if not.
bool MotionPlan::RRT::checkGoal(const TreeNode* checkNode){
  double dx = xGoal - checkNode->x;
  double dy = yGoal - checkNode->y;
  double dz = zGoal - checkNode->z;

  if ((dx*dx + dy*dy + dz*dz) <= stepSize*stepSize){
    // return link(xMin, xMax, yMin, yMax, zMin, zMax, numObstacles, checkNode->x, checkNode->y, checkNode->z, xGoal, yGoal, zGoal);
  }else{
    return false;
  }
}

// First clears the tree of any info that may have been left over
// from a previous pathfind.
// While a path to the goal hasn't been found and we haven't iterated
// more than MAX_ITERATIONS:
// Generate a random sample, find the nearest node to that sample,
// attempt to make a new node stepSize away from the nearest node in the
// direction of the random sample, and if that works, add it to the tree
// and check if it's close enough to the goal to try a link() to it. If
// the goal has been reached, add a new node to the tree that represents
// the goal position.
// If the goal was added to the tree, find the path to it by starting at
// the goal and building a path backwards through its parents. Reverse this
// list, and you have the path.
// If the goal was never added to the tree, return false.
bool MotionPlan::RRT::findPath(int* iterations, int* nodePath, int* pathLength){

  if (root != NULL){
    root->deleteChildren();
  }
  else{
    root = new TreeNode;
    root->parent = NULL;
    root->nodeID = 0;
    nodes.push_back(root);
  }

  root->x = xStart;
  root->y = yStart;
  root->z = zStart;

  nodes.clear();
  edges.clear();

  nodes.push_back(root);

  (*iterations) = 0;
  bool goalReached = false;
  TreeNode* goal = NULL;

  while (!goalReached && (*iterations) < MAX_ITERATIONS){
    ++(*iterations);

    double sampleX, sampleY, sampleZ;
    TreeNode* near = NULL;
    TreeNode* newNode = NULL;

    randFreeSample(&sampleX, &sampleY, &sampleZ);
    near = nearestNode(sampleX, sampleY, sampleZ);

    newNode = genNewNode(near, sampleX, sampleY, sampleZ);
    if (newNode != NULL){
      newNode->parent = near;
      near->children.push_back(newNode);

      newNode->nodeID = nodes.size();
      nodes.push_back(newNode);
      edges.push_back(Edge(near->nodeID, newNode->nodeID));

      if (checkGoal(newNode)){
        goal = new TreeNode;
        goal->x = xGoal;
        goal->y = yGoal;
        goal->parent = newNode;
        newNode->children.push_back(goal);
        goalReached = true;

        goal->nodeID = nodes.size();
        nodes.push_back(goal);
        edges.push_back(Edge(newNode->nodeID, goal->nodeID));
      }
    }
  } // end while goal hasn't been reached

  if (goal != NULL){

    std::vector<int> reversePath;
    for (TreeNode* current = goal; current != NULL; current = current->parent){
      reversePath.push_back(current->nodeID);
    }

    (*pathLength) = reversePath.size();

    for (int i = 0; i < (*pathLength); ++i){
      nodePath[(*pathLength)-1-i] = reversePath[i];
    }

    return true;
  }
  else{
    nodePath = NULL;
    return false;
  }
}

void MotionPlan::RRT::outputTree(std::ostream &outStream)
{
  //ノードの座標を2点ずつのブロックでファイルに書き込み
  for (int i = 0; i < edges.size(); ++i){
    outStream << (nodes[edges[i].node1])->x << "\t" << (nodes[edges[i].node1])->y << std::endl;
    outStream << (nodes[edges[i].node2])->x << "\t" << (nodes[edges[i].node2])->y << std::endl;
    outStream << "\n" << std::endl;

    usleep(30000);
  }
}

void MotionPlan::RRT::outputTree(FILE *outStream)
{
  for (int i = 0; i < edges.size(); ++i){
    std::cout << i << "番目のループだよ" << std::endl;
    //fprintf(outStream, "plot '-' using 1:2 with lines");

      fprintf(outStream,"%lf %lf\n", ((nodes[edges[i].node1])->x), ((nodes[edges[i].node1])->y));
      fprintf(outStream,"%lf %lf\n\n", ((nodes[edges[i].node2])->x), ((nodes[edges[i].node2])->y));
      fprintf(outStream,"e\n"); //データ書き込み終了を知らせる．
    //}
    fflush(outStream);


    for(int k=0; k<50; ++k){
      usleep(10000);
    }

  }
}

void MotionPlan::RRT::gnuplot_config(FILE *outStream)
{

  outStream = popen("gnuplot -persist", "w");    /*プログラムが終了後GnuplotのWindowを閉じない*/
  //outStream = popen("gnuplot", "w");               /*プログラムが終了後GnuplotのWindowを閉じる*/
  fprintf(outStream,"set terminal gif animate optimize size \n");
  fprintf(outStream,"set output 'anime.gif'\n");

  /*アニメーションをgif動画として保存する場合は，上のコメントを解除*/
  fprintf(outStream,"set xtics 0.5\n");
  fprintf(outStream,"set ytics 0.5\n");
  fprintf(outStream,"set xlabel 'x' font 'Times, 20'\n");
  fprintf(outStream,"set ylabel 'y' font 'Times, 20'\n");
  fprintf(outStream,"set grid\n");
  fprintf(outStream,"set size square\n");
}
